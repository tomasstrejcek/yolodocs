---
phase: 03-sidebar-and-page-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/site/src/components/layout/Sidebar.tsx
  - src/site/src/components/search/SearchDialog.tsx
autonomous: true
requirements: [NAV-01, NAV-02, NAV-04, NAV-05, NAV-07]

must_haves:
  truths:
    - "SidebarSubGroup collapse state persists across SPA page navigations using localStorage"
    - "SidebarSubGroup auto-expands when the active page is one of its children"
    - "A 3-level docs folder renders section, collapsible group, and leaf link in the sidebar"
    - "Active page is highlighted in the sidebar regardless of nesting depth"
    - "SearchDialog indexes pages nested inside groups (item.children) so they appear in search results"
  artifacts:
    - path: "src/site/src/components/layout/Sidebar.tsx"
      provides: "localStorage-backed collapse state and auto-expand behavior"
      contains: "localStorage"
    - path: "src/site/src/components/search/SearchDialog.tsx"
      provides: "Recursive flattening of manifest items including children"
      contains: "flattenNavItems"
  key_links:
    - from: "src/site/src/components/layout/Sidebar.tsx"
      to: "manifest.json sections[].items[].children[]"
      via: "SidebarSubGroup reads children and persists group collapse state by item.id"
      pattern: "sidebar-group-"
    - from: "src/site/src/components/search/SearchDialog.tsx"
      to: "manifest.json sections[].items[].children[]"
      via: "flattenNavItems recurses into children to populate search index"
      pattern: "flattenNavItems"
---

<objective>
Add localStorage-backed collapse persistence and active-child auto-expansion to SidebarSubGroup, and fix SearchDialog to index nested group children.

Purpose: Sidebar groups must retain their expanded/collapsed state across SPA navigation (NAV-05) and auto-expand when the user lands directly on a URL for a page inside the group (NAV-07). The SearchDialog must also index pages nested inside groups so they are findable via search. NAV-01, NAV-02, and NAV-04 are already structurally satisfied by the existing rendering and are verified here.

Output: Updated `Sidebar.tsx` with localStorage persistence and auto-expand, updated `SearchDialog.tsx` with recursive item flattening.
</objective>

<execution_context>
@/Users/tomasstrejcek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tomasstrejcek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sidebar-and-page-rendering/03-RESEARCH.md
@.planning/phases/02-flat-html-output/02-02-SUMMARY.md
@src/site/src/components/layout/Sidebar.tsx
@src/site/src/components/search/SearchDialog.tsx
@src/site/src/lib/auth-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add localStorage-backed collapse persistence to SidebarSubGroup</name>
  <files>src/site/src/components/layout/Sidebar.tsx</files>
  <action>
In `SidebarSubGroup`, replace the simple `createSignal(false)` for `collapsed` state with a localStorage-backed signal. This ensures collapse state survives SPA navigation and full page reloads.

**Import `createEffect` at the top** (add it to the existing SolidJS import if not present -- check the import line first; `createEffect` is NOT currently imported in Sidebar.tsx, only `createSignal, Show, For, onMount, onCleanup`).

Update the import line:
```typescript
import { For, createSignal, createEffect, Show, onMount, onCleanup } from "solid-js";
```

**Replace the current SidebarSubGroup collapse logic:**

Current code (line 148):
```typescript
const [collapsed, setCollapsed] = createSignal(false);
```

Replace with:
```typescript
const STORAGE_KEY = `sidebar-group-${props.item.id}`;

const [collapsed, setCollapsed] = createSignal<boolean>(
  (() => {
    try {
      if (typeof window === "undefined") return false;
      const stored = localStorage.getItem(STORAGE_KEY);
      return stored !== null ? stored === "true" : false;
    } catch {
      return false;
    }
  })()
);
```

**Add auto-expand effect** immediately after the `hasActiveChild` declaration (after line 151):
```typescript
// NAV-07: auto-expand when active child is inside this group
createEffect(() => {
  if (hasActiveChild() && collapsed()) {
    setCollapsed(false);
    try { localStorage.setItem(STORAGE_KEY, "false"); } catch {}
  }
});
```

**Replace the toggle handler.** The current toggle is inline `onClick={() => setCollapsed(!collapsed())}` on the button (line 161). Replace the button's `onClick` to persist:

Change the button onClick from:
```typescript
onClick={() => setCollapsed(!collapsed())}
```

To:
```typescript
onClick={() => {
  const next = !collapsed();
  setCollapsed(next);
  try { localStorage.setItem(STORAGE_KEY, String(next)); } catch {}
}}
```

**Key details:**
- The `typeof window === "undefined"` guard prevents SSR prerender crashes (matches existing pattern at Sidebar.tsx line 21).
- Using `props.item.id` as the storage key ensures uniqueness -- item IDs include the full path (e.g., `docs-folder-guides`).
- The `try/catch` blocks handle localStorage quota errors and privacy-mode browsers gracefully.
- The `createEffect` for auto-expand is safe from infinite loops: once `setCollapsed(false)` runs, `collapsed()` becomes `false`, so the condition `hasActiveChild() && collapsed()` is false on the next evaluation.
  </action>
  <verify>
Visually inspect the `SidebarSubGroup` function in Sidebar.tsx:
1. `createEffect` is imported from solid-js
2. `STORAGE_KEY` uses `props.item.id` (not group name)
3. `createSignal` initializer reads from localStorage with `typeof window` guard
4. `createEffect` auto-expands when `hasActiveChild() && collapsed()`
5. Button onClick persists to localStorage
6. All localStorage access is wrapped in try/catch
  </verify>
  <done>SidebarSubGroup uses localStorage-backed collapse state. Groups persist expanded/collapsed across navigation. Active child auto-expands the group on direct URL access.</done>
</task>

<task type="auto">
  <name>Task 2: Fix SearchDialog to recurse into group children</name>
  <files>src/site/src/components/search/SearchDialog.tsx</files>
  <action>
The current `allItems` population loop (lines 20-31) only pushes top-level `section.items` into the search index. Items with `children` (group parents) have no anchor and are not navigable, but their children ARE navigable pages that should appear in search results.

**Add a recursive helper function** before the `allItems` declaration (before line 20):

```typescript
function flattenNavItems(
  items: any[],
  sectionTitle: string,
  into: SearchResult[]
): void {
  for (const item of items) {
    if (item.children && item.children.length > 0) {
      // Group header: not navigable itself, recurse into children
      flattenNavItems(item.children, sectionTitle, into);
    } else if (item.anchor) {
      into.push({
        id: item.id,
        name: item.name,
        section: sectionTitle,
        anchor: item.anchor,
        description: item.description || "",
      });
    }
  }
}
```

**Replace the current allItems population block** (lines 20-31):

Current code:
```typescript
const allItems: SearchResult[] = [];
for (const section of (manifest as any).sections || []) {
  for (const item of section.items) {
    allItems.push({
      id: item.id,
      name: item.name,
      section: section.title,
      anchor: item.anchor,
      description: item.description || "",
    });
  }
}
```

Replace with:
```typescript
const allItems: SearchResult[] = [];
for (const section of (manifest as any).sections || []) {
  flattenNavItems(section.items, section.title, allItems);
}
```

**Key details:**
- Group parents (items with children but no anchor) are skipped -- they are category headers, not navigable pages.
- Leaf items (items with anchor, no children) are added to the search index.
- This handles any depth up to the 3-level cap: section items that are groups get recursed, and their children (leaf pages) get indexed.
- The `flattenNavItems` function is defined inside the component's module scope (outside the component function) since it operates on static data.
  </action>
  <verify>
Visually inspect SearchDialog.tsx:
1. `flattenNavItems` function exists before the component
2. The function recurses when `item.children` is present
3. The function pushes items with `item.anchor` (leaf pages)
4. The `allItems` block uses `flattenNavItems` instead of the flat loop
5. The "Type to search across N schema items" count at the bottom should include nested pages
  </verify>
  <done>SearchDialog recursively flattens group children into the search index. Nested doc pages (e.g., guides/filtering) are now findable via search.</done>
</task>

<task type="auto">
  <name>Task 3: Build, integration test, and verify sidebar behavior</name>
  <files></files>
  <action>
Run the build pipeline and integration test to verify all sidebar changes work end-to-end.

```bash
npm run build
rm -rf test-output && node dist/bin/yolodocs.js --schema schema.graphql --output test-output --title "Carl API" --docs-dir ./docs
```

After the integration build completes, verify:

1. **3-level hierarchy renders (NAV-01, NAV-02):** The docs directory has `guides/filtering.md`, `guides/sorting.md`, `guides/real-time-updates.md` and `advanced/custom-scalars.md`, `advanced/performance.md`. These should produce group items in the manifest. Check:
   ```bash
   cat test-output/_build/manifest.json | python3 -m json.tool | grep -A 5 '"children"'
   ```
   Verify groups have children arrays with leaf page entries.

2. **Active state works (NAV-04):** Inspect the generated HTML for sidebar `classList` bindings that use `activeId`. No runtime test possible in CLI -- visual verification via `npx serve test-output -p 3456` if desired.

3. **SearchDialog includes nested pages:** Check the search dialog's item count by searching for `allItems.length` in the built output -- or verify by opening the site and using Cmd+K search for a nested page like "Filtering".

4. **No build errors, no TypeScript errors.**

Clean up: `rm -rf test-output`
  </action>
  <verify>
1. `npm run build` completes without errors
2. Integration build produces output in test-output/
3. Manifest JSON contains groups with children arrays
4. No runtime errors in build log
  </verify>
  <done>Build succeeds. Integration test produces correct 3-level hierarchy. SearchDialog indexes nested pages. dist/ is up to date.</done>
</task>

</tasks>

<verification>
1. `npm run build` -- TypeScript compiles without errors
2. Integration build (`node dist/bin/yolodocs.js ...`) succeeds
3. Manifest JSON contains group items with `children` arrays for `guides/` and `advanced/` folders
4. `Sidebar.tsx` contains `localStorage.getItem` and `localStorage.setItem` calls in SidebarSubGroup
5. `Sidebar.tsx` contains `createEffect` for auto-expand behavior
6. `SearchDialog.tsx` contains `flattenNavItems` recursive function
7. SearchDialog `allItems` population uses `flattenNavItems` instead of flat loop
</verification>

<success_criteria>
- SidebarSubGroup reads collapse state from localStorage on mount (keyed by item.id)
- SidebarSubGroup persists collapse state to localStorage on toggle
- SidebarSubGroup auto-expands when hasActiveChild() is true (via createEffect)
- SearchDialog recursively indexes items nested inside groups
- Integration build produces correct 3-level sidebar hierarchy
- dist/ is compiled and up to date
</success_criteria>

<output>
After completion, create `.planning/phases/03-sidebar-and-page-rendering/03-01-SUMMARY.md`
</output>
